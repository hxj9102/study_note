# webpack打包产物分析

在日常开发中，我们可能经常使用webpack作为打包工具去构建很多项目，并使打包出来的代码在不同的平台上运行。然而，对于打包出来的代码是什么，我们却很少关注，今天我们来聊聊webpack打包出来的代码是什么。

## 运行环境

webpack@4.46.0

webpack-cli@3.3.12

node@14.16.0

## 准备工作

使用npm初始化一个项目，然后安装webpack、webpack-cli依赖，在根目录下新建webpack.config.js文件，配置如下：

``` javascript
const path = require('path')

module.exports = {
    mode: 'development', // 使用开发模式，打包出来的代码不会被严格压缩，方便代码分析
    entry: './src/index.js', // 配置入口
    output: { // 打包出口配置
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    }
}
```

接下来我们分四种情况分析webpack打包产物

* 不引入模块时
* 同步引入模块时
* 异步引入模块时
* 使用spiltChunks时

## 不引入模块时

src/index.js

``` javascript
console.log('hello webpack')
```

当入口文件不引入任何模块时，我们在入口文件中写入`console.log('hello webpack')`这行代码，然后在项目根目录下执行`webpack`命令，之后在`dist`目录下生成`bundle.js`。我们打开bundle文件探个究竟。

为了方便分析，我们把代码简化为以下。

从下面这段代码，我们可以知道最外层是一个立即执行函数,传入的参数modules是一个对象，key代表是模块的路径，value是一个函数，函数传入了两个参数，分别是module和exports。

``` javascript
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("console.log('hello webpack')\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });
```

接着我们看一下函数体的内容，首先定义了`installedModules`对象和`__webpack_require__`函数，然后在`__webpack_require__`函数上挂载了一些静态方法和属性，最后函数return了`__webpack_require__(__webpack_require__.s = "./src/index.js")`。我们先来看看`__webpack_require__`这个函数。

### `__webpack_require__`

``` javascript
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
```

从上面代码可以看出，`__webpack_require__`函数接收一个`moduleId`作为参数，而从`__webpack_require__(__webpack_require__.s = "./src/index.js")`这行代码我们知道`moduleId`即模块的路径，接着我们先看以下这段代码，这里定义了一个变量module，并且将moduleId作为installedModules的属性，为其赋值一个对象，这个对象包含三个属性分别是i（代表模块id），l（是否完成加载），exports（输出模块的内容）。

``` javascript
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
```

接着通过modules[moduleId]获取对应的模块函数并执行，在函数中分别传入module, module.exports, `__webpack_require__`，从这里可以看出以下模块路径对应的函数参数就是从这里传入的。由此我们也可以知道入口文件的代码是在这里被执行的。

``` javascript
/***/ (function(module, exports) {

eval("console.log('hello webpack')\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })
```

当模块执行完之后，把module.l置为true，代表模块加载完成，最后把module.exports给return出去。

由此可知installedModules的作用就是用于缓存模块。

然后我们再回到`__webpack_require__`函数开头的if语句，从这个代码我们可以知道加载模块的时候会先检查模块是否已经在缓存中，如果存在缓存中，则直接从缓存中加载，否则把它当做一个新模块加载。

``` javascript
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
```

关于`__webpack_require__`上定义的方法和属性的作用，把他们放在文章的最后面统一分析，因为第二部分和第三部分打包出来的代码会新增一些方法或属性。

至此，第一部分基本分析完毕。接下来我们来分析一下如果在入口文件中引入一个同步模块或异步模块，打包的代码会有什么变化。

大家在这里可能有个疑问，为什么要把同步模块和异步模块分开来分析呢，原因是同步和异步模块的加载方式不一样。

## 引入同步模块

我们新增一个log.js文件，这个文件暴露一个logInfo方法，并且在index.js中引入并调用。

src/log.js

``` javascript
export function logInfo ()  {
    console.log(...arguments)
}
```

src/index.js

``` javascript
import {logInfo} from './log'

logInfo('hello webpack')
```

打包之后与第一次打包进行对比，发现函数体的定义没有变化，不同的地方在于传给modules的对象发生变化了：

```javascript
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ \"./src/log.js\");\n\r\n\r\nObject(_log__WEBPACK_IMPORTED_MODULE_0__[\"logInfo\"])('hello webpack')\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/log.js":
/*!********************!*\
  !*** ./src/log.js ***!
  \********************/
/*! exports provided: logInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logInfo\", function() { return logInfo; });\nfunction logInfo ()  {\r\n    console.log(...arguments)\r\n}\r\n\n\n//# sourceURL=webpack:///./src/log.js?");

/***/ })

/******/ });
```

为了方便我们分析，我们把每个入口对应函数中的eval的字符串进行格式化，得到

``` javascript
/*line 1 */ // ./src/index.js
/*line 2 */ __webpack_require__.r(__webpack_exports__);
/*line 3 */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "./src/log.js");
/*line 4 */ Object(_log__WEBPACK_IMPORTED_MODULE_0__["logInfo"])('hello webpack')
/*line 5 */
/*line 6 */ // ./src/log.js
/*line 7 */ __webpack_require__.r(__webpack_exports__);
/*line 8 */ __webpack_require__.d(__webpack_exports__, "logInfo", function() { return logInfo; });
/*line 9 */ function logInfo ()  {
/*line 10*/     console.log(...arguments)
/*line 11*/ }
```

从以上代码我们可以知道第三行代码相当于我们源码中的`import {logInfo} from './log'`，`_log__WEBPACK_IMPORTED_MODULE_0__`可以看成是log模块，它的值由`__webpack_require__(/*! ./log */ "./src/log.js")`执行而得到，当执行`__webpack_require__(/*! ./log */ "./src/log.js")`时，主要的代码逻辑就是在log模块上挂载logInfo属性，并将logInfo函数复制给它，logInfo函数其实就是我们在log.js中暴露出来的。

## 引入异步模块

在这里首先我们需要知道什么是异步模块，在webpack中，异步引入模块的方法有`require.ensure`和import() 。接下来我们通过import的方式引入log模块，我们把index.js的代码修改为

src/index.js

``` javascript
import('./log').then(Log => Log.logInfo('hello webpack'))
```

此时打包出来的代码会和之前的代码有比较大的不同，先分析函数体代码的不同

``` javascript
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {};

/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/

/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + chunkId + ".bundle.js"
/******/ 	}

/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {};

			// 这行代码先检测window["webpackJsonp"]是否存在，如果不存在则复制一个空数组
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
			// 缓存jsonpArray原始的push方法，作用呢？
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
			// 将jsonpArray的push方法改为webpackJsonpCallback
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
			// 下面的这段代码可以看出，代码执行到这里的时候jsonpArray可能不是空数组，为什么？ 其实这里就说明了在执行主chunk之前，jsonpArray就已经被赋值了
			// 从这里也可以看出，无论是在主chunk执行之前还是在主chunk执行之后加载的其他chunk都会被webpackJsonpCallback函数执行
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
			// 将oldJsonpFunction复制给parentJsonpFunction
/******/ 	var parentJsonpFunction = oldJsonpFunction;
```

为了方便理解webpackJsonpCallback这个函数，我们需要先看一下0.bundle.js的代码。

### 0.bundle.js

从这个文件我们可以知道，当这个文件请求完成后，会执行以下代码，window["webpackJsonp"]push了一个数组，这个数组的第一项存放了模块的id，即0.bundle.js的0，作用是为了加载模块，第二项是模块的对应关系。

``` javascript
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{
    // ...省略
}]);
```

看完0.bundle.js代码之后，我们接着看installedChunks对象。

### installedChunks

记录加载的模块，key表示模块id，value表示模块加载状态，下面用表格表示value值所对应的状态说明。

| value     | 说明                                  |
| --------- | ------------------------------------- |
| undefined | 模块没有被加载                        |
| null      | 通过preloaded或prefetched预加载的模块 |
| Promise   | 模块正在加载中                        |
| 0         | 模块已加载完成                        |

我们知道一开始installedChunks对象中存在属性main为0，这里恰好说明了主chunk的模块id被标注为main，代码能执行到这里肯定是主chunk已经完成了加载，所以值为0。

在分析webpackJsonpCallback之前，我们还需要再分析一下__webpack_require__.e这个函数。

### __webpack_require__.e

<img src="C:\Users\N20219\Desktop\学习笔记\imgs\__webpack_require__.e.png" style="float: left; zoom: 67%;" />

resolve函数被调用的地方是在webpackJsonpCallback中

从代码看，函数体定义了一个promises，最后返回了Promise.all(promises)

这个函数的主要作用是通过动态的script加载方式请求相应模块，并且返回一个Promise.all()，这里涉及到几个问题

* 当一个模块在不同地方同时被调用
* 当一个模块请求失败时

``` javascript
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/		// 获取chunkId对应的状态
/******/ 		var installedChunkData = installedChunks[chunkId];
    			 // 为0表示模块已经被加载，这里模块没有被加载或者处于加载中状态
/******/ 		if(installedChunkData !== 0) {
/******/
/******/ 			// 模块加载中
/******/ 			if(installedChunkData) {
    					// 把原来的promise push进来
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else { // 模块未被加载
/******/ 				// 创建一个promise
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
    					// 从这里可知，当模块即将被加载时，installedChunks[chunkId]是一个数组，第一项为resovle，第二项为reject，第三项为promise
/******/
/******/ 				// 开始请求模块
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
    					// jsonpScriptSrc(chunkId)：拼接模块路径
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
    						// 同一个模块可能会同时发起多个请求，这里需要进行判断
/******/ 					var chunk = installedChunks[chunkId];
    						// chunk没有被成功加载
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
    					// 无论加载成功还是失败都会调用onScriptComplete函数
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
```

在了解了0.bundle.js的代码、installedChunks和__webpack_require__.e，接下来我们来分析一下webpackJsonpCallback。

### webpackJsonpCallback

通过对webpackJsonpCallback函数的分析，我们可以知道这个函数的作用有：

* 改变installedChunks[chunkId]的状态为加载完成
* 把其他chunk的模块对象拷贝到主chunk的modules对象上
* 改变__webpack_require__.e中的promise状态

``` javascript
/******/ 	function webpackJsonpCallback(data) {
    			// 获取模块id
/******/ 		var chunkIds = data[0];
    			// 获取模块对象
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
    				// 理解这个判断条件需要结合__webpack_require__.e函数
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
    					// installedChunks[chunkId][0]是一个resolve函数，在__webpack_require__.e中被赋值
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
    				// 执行到这里，说明模块被加载完成
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
    			// 把加载的模块对象拷贝到modules上
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
    			// 为什么要这么做？
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
    			// 执行resove函数，promise状态改变，即模块完成了加载
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
```



我们再回头来看一下主chunk入口的代码，当执行__webpack_require__.e(/*! import() */ 0)时，会请求id为0的模块，并返回promise，当模块请求完成后，会执行webpackJsonpCallback，并执行了resolve函数，即promise状态发生改变。

接着会执行__webpack_require__.bind(null, /*! ./log */ "./src/log.js")，这个函数缓存了./src/log.js暴露的信息，并返回了module.exports。

最后再获取module.exports即Log的logInfo属性并执行。

``` javascript
__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./log */ "./src/log.js")).then(Log => Log.logInfo('hello webpack'))
```



## 使用spiltChunks时

我们把webpack.config.js代码修改为

``` javascript
const path = require('path')

module.exports = {
    mode: 'development',
    entry: {
        bundle: './src/index.js',
        log: './src/log.js'
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js'
    },
    optimization: {
        splitChunks: {
            chunks: "all",
            minSize: 0
        }
    }
}
```

打包后，我们发现除了生成bundle.js和log.js，还生成了bundle~log.js。从webpack.config.js的入口配置，我们可以知道入口bundle依赖了log.js，而入口log也依赖了log.js，由此可以把log.js提取为共用模块，因此bundle~log.js就是它们的公用模块。

``` javascript
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["bundle~log"],{

/***/ "./src/log.js":
/*!********************!*\
  !*** ./src/log.js ***!
  \********************/
/*! exports provided: logInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logInfo\", function() { return logInfo; });\nfunction logInfo ()  {\r\n    console.log(...arguments)\r\n}\r\n\n\n//# sourceURL=webpack:///./src/log.js?");

/***/ })

}]);
```

### deferredModules

deferredModules是一个数组，它的每一项也是一个数组（这个数组的第一项为入口模块，从第二项开始为依赖模块，例如deferredModules[["./src/index.js","bundle~log"]]，）

### checkDeferredModules

这个函数的作用主要是检测入口模块所依赖的其他模块是否全部完成了加载，如果是，则执行入口模块，否则则等待所有依赖模块完成加载。

``` javascript
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
    				// 注意j从1开始，因为只需要检测被依赖的模块是否完成了加载
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
    					// 被依赖的模块id
/******/ 				var depId = deferredModule[j];
    					// 只要被依赖的模块有任何一个没有完成加载，那么fulfilled为false
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
    				// 如果fulfilled为true，说明依赖的模块都已经完成加载
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
    					// 执行入口模块
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
```

对于一些公共代码，我们会在主要代码之前引入。所以，正常情况下我们会这么引入,控制台可以打印出`hello webpack`

``` html
<script src="bundle~log.js"></script>
<script src="bundle.js"></script>
```

而如果我们这样引入呢？这种方式同样可以打印出hello webpack。公共代码会在主代码之后加载，其实我们可以看一下在webpackJsonpCallback函数底部的一行代码`return checkDeferredModules();`，这行代码就是保证了在加载`bundle~log.js`之后再去执行入口的代码。

``` html
<script src="bundle.js"></script>
<script src="bundle~log.js"></script>
```



## 附录

### \__webpack_require__.m

用于暴露modules对象

### \__webpack_require__.c

用于暴露installedModules对象

### \__webpack_require__.o

判断一个对象自身是否存在某个属性

### \__webpack_require__.d

为模块的exports对象定义属性

### \__webpack_require__.r

为模块的exports对象定义__esModule属性，并将其值设置为true

### \__webpack_require__.t



### \__webpack_require__.n



### \__webpack_require__.p

等于在webpack.config.js中output中定义的publicPath，在异步加载请求时会将这个值拼接到moduleId前面。

### \__webpack_require__.s

存放入口路径



## Q&A

* installedModules和installedChunks的区别是什么？
* 